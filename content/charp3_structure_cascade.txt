继承：从一个元素向其后代元素传递属性所采用的机制

1. 特殊性
    1) 如果一个元素有两个或多个冲突的属性声明，那么有最高特殊性的声明就会胜出
        注意： 这并非解决冲突的全部。实际上所有样式的冲突都由层叠来处理
    
    2) 特殊性计算（高位 -> 低位）
        ID  [class, attr, pseudo-class] [elements, pseudo-elements]
        0   0                           0
    
    3) 特殊性和声明
    出现冲突的属性声明时，用户代理会自动计算特殊性并根据特殊性决定使用哪条声明

    4) 通配符选择特殊性
    通配符对选择器的特殊性计算没有贡献（0特殊性）
    5) ID 特殊性
    6) 内联样式特殊性 （最高与ID选择器特殊性相同，换句话说ID选择器很容易覆盖内联样式）
        当元素有内联样式时，会优先使用内联样式
    7) 重要性 (!important)
        重要声明的特殊性冲突会在重要声明内部解决，而不会与非重要声明相混
        如果一个重要声明和一个非重要声明冲突，胜出的总是重要声明

2. 继承
    1) 基于继承，样式不仅会应用到指定元素，还会应用到它的后代元素

    2) 元素不会把值传递到器祖先
        例外：HTML中，应用到body元素的背景样式可以传递到html元素，响应地可以定义其画布

    3) 有些属性不能继承
        一般地，大多数框模型属性（包括外边距、内边距、背景和边距）都不能继承
        继承的值没有特殊性，甚至连0特殊性都没有
        通配选择器往往有一种短路继承的效果，更合理的做法是从一开始就避免不加区别地使用通配选择器，从而从根本上避免这个问题

3. 层叠
    css层叠规则：
        1)  找出所有相关的规则， 这些规则都包含与一个给定元素匹配的选择器
        2)  按显示权重对应用到该元素的所有声明排序。(!important > 来源)
        3） 按特殊性对应用到给定元素的所有声明排序
        4)  按出现顺序对应用到给定元素的所有声明排序 （出现越靠后，权重越大）

    按权重来源排序：
          读者的重要声明 > 创作人员的重要声明 > 创作人员的正常声明 > 读者的正常声明 > 用户代理声明

    内联样式声明高于所有样式表选择器
    通过将伪类连接在一起能够缓解特殊性和顺序带来的问题
    非CSS表现提示
        非CSS提示被处理为特殊性为0，并出现在创作人员样式表的最前面，只要有创作人员和读者样式，这种表现提示就会被覆盖，但是用户代理样式不能将其覆盖





    